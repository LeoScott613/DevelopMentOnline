即使在赋值语句中使用b--也是会使b的值减1的
试图使b的值不变，只想让a=b-1而使用b--，目的不会达到，会使b原来的值赋给a，然后b自减

整数/整数=整数，不会四舍五入，全舍

//如果一个作用域A在另一个作用域B以内，在用using声明作用域A时要:using B::A;

gets()读取的字符串如果目标字符数组存储不下，多余的部分会直接舍弃

int main()以外的作用域和int main()以内的作用域不是同一个作用域

\\输出的是一条\，%%输出的是一个%

指针函数的返回值是一个指针。不过应该注意的是，这个函数体中返回的指针变量不能指向一个普通的局部变量(函数体中)。
比如说在int *func(int sum)函数体中定义了一个*ret指针指向最终运算结果的地址&res，那么这res变量应该有static进行修饰
原因在于普通局部变量存储在“栈区”中，在外部函数(比如这个int *func(int sum))调用结束后变量的空间就会被释放。
因为在主函数中，我们使用一个指针去指向这个“很快会被释放的变量”，如果没有在得到返回值后马上访问，那么这个变量很快就被释放掉了，而主函数中指向它的那个指针也就无所指了
而static型的变量不会有这个问题，它存放在“数据段”中，生命周期是整个程序运行期间，只要程序没有结束就会一直存在。
另外，使用全局变量也是一样的，不过“不推荐”
//延伸思考(Perfomance): static型和全局变量的生命周期是整个程序，因此要考虑占用的问题

scanf函数读取到不按格式进行的输入时不会将值赋给变量，比如%d却输入一个%c。同时,scanf会返回0
如果有正确的输入就会返回1(即使只有一个也会返回1)
如果输入错误了就会返回EOF,也就是-1

假设有scope A < scope B. When a virable named the same as a virable in scope B is defined in scope A, it will cover that one in scope B. 
所以对这个变量进行赋值，调用时不会scope B中的那个变量有操作

vector::size_type? Wrong! vector<类型>::size_type.

在C++源文件中(.cpp), 使用printf(),scanf()等stdio.h函数时，要引入:"#include <cstdio>"

不存在从int直接转换为string的构造函数，在c++中要使用stringstream对象进行操作，不过耗时很大

一个字符型数组要想和stirng类型变量拼接起来需要用string进行转化:char buff[1];string buf=string(buff);转化后，如果char数组是一个未填满的数组，string会截取已填充部分，并且在\0之后的字符也会舍弃。因此转化后的长度可能小于原数组长度

如果程序的开头定义了一个索引很大的数组会导致程序无法运行

'\0'实际上是作为字符串结束符使用的，当读到这个字符时便会停止输出.而在用string转化一个字符数组时， \0之后的部分会被截去. 如果一个字符数组的结尾没有\0,那么就会导致输出错误

cin无法直接对数组进行输入，如int a[10];cin>>a; //error

动态数组这样定义type *p=new type[length];使用上就使用p[n],效果等同静态数组

const char*类型，即使用#define定义的字符串类型是可以直接复制给cpp的string类型使用的

让一个指针指向一个数组的正确做法是int a[2]={1,2};int *p=a;因为使用a的时候意味着指向a[0]的指针  

赋值表达式的值为赋值后左值的值

strcpy不能传入两个*char[]，这样传入是非法的，两个*char[]要进行复制直接使用赋值即可，比如tempo[1]=argv[1];

C++中，""是错误的，但是C中是合法的

C语言中也有const限定符只不过谭浩强的书中没有提到

用scanf(%d)输入的数据即使有前导0也可以成功输入

如果两个int进行运算超出了int的范围，即使预算存在大型变量里也会发生溢出

用%c占位符读取输入时，输入的是3，存入的会是字符3，用%d会存入数字3

scanf("%s");输入方式会将空格作为分隔符; gets方式会把空格读入