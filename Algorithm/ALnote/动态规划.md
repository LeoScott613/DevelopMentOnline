# 动态规划
*动态规划有四类：线性，背包，树形，区域*  
动态规划的基本思想是将待求解问题分解为子问题，先求解子问题再从子问题的解得出原问题的解  

**适合使用动态规划的问题**
1. 具有重叠子问题。不同的问题，可能要求同一个子问题的解  
2. 具有最优子结构。最优解肯定是由最优的子解转移推导而来，子解必定也是子问题的最优解
3. 具有无后效性。先求解的子问题的结果不会因为后面求出来的问题而改变

**进行动态规划的过程**
1. 划分状态，即划分子问题
2. 状态表示，即使用计算机处理子问题
3. 状态转移，即父问题是如何由子问题推导出来的
4. 确定边界，确定初始状态是什么？最小的子问题？最终状态又是什么

*以上这些不过是理论知识，而且要从题目中找到动态规划的特征也不容易，下面是自己的理解*  
## 一个用动态规划解决的问题
>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法  
注：跳法是什么？123456789X和2468X分别是两种不同的跳法，不要和步数的概念混淆  
**跳法！=步数**

可以把青蛙跳上第n级台阶的跳法种数设为f(n)  
那么题目需要求解的就是**f(10)**  
根据条件，跳上第十个台阶之前可能在第9个也可能在第8个台阶，故f(10)=f(9)+(8)  
同理可以知道f(9)=f(8)+f(7)  
因此可以推知f(n)=f(n-1)+f(n-2)  
这个公式当然是在n大于3时成立  
而n=2和n=1时易解得f(2)=2, f(1)=1  
所以就**把难以解决的问题分解成了可以解决的子问题**  

```java
/**
 * @author: https://juejin.cn/post/6951922898638471181#heading-5  
 * @note: 没有备忘录机制的递归，重复计算的次数很多
 */
class Solution {
    public int numWays(int n) {
    if(n == 1){
        return 1;
    }
     if(n == 2){
        return 2;
    }
    return numWays(n-1) + numWays(n-2);
    }
}
/**
 * @note: 有备忘录机制，解决过的子问题可以保存下来，因而不用重复解决子问题
 */
public class Solution {
    //使用哈希map，充当备忘录的作用
    Map<Integer, Integer> tempMap = new HashMap();
    public int numWays(int n) {
        // n = 0 也算1种
        if (n == 0) {
            return 1;
        }
        if (n <= 2) {
            return n;
        }
        //先判断有没计算过，即看看备忘录有没有
        if (tempMap.containsKey(n)) {
            //备忘录有，即计算过，直接返回
            return tempMap.get(n);
        } else {
            // 备忘录没有，即没有计算过，执行递归计算,并且把结果保存到备忘录map中，对1000000007取余（这个是leetcode题目规定的）
            tempMap.put(n, (numWays(n - 1) + numWays(n - 2)) % 1000000007);
            return tempMap.get(n);
        }
    }
}
```

## 实际经验
动态规划的一种做法是用函数递归+备忘录，但是这样子可能导致代码冗余，比如计算卡特兰数这种就可以使用数组存数据并在数组内进行递推。  