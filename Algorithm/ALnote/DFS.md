# 深度优先搜索
**深度优先搜索体现的思想就是其名字**  

*例子：二叉树的先序，中序，后序遍历*  

深度优先搜索属于图算法的一种.简要来说，程序对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。比如在三种顺序的二叉树遍历中，每一个节点就是只访问一次的。  
DFS算法有一个**起始节点**，程序是从这个起始节点进行搜索的。之后就是访问这个起始节点的临近节点。之后，程序就在这个临近节点之后的所有路径上进行搜索，如果没有找到需要的路径，那么才到起始节点的另一个临近节点进行搜索。  
实际上，DFS是用递归实现的。比如深度优先搜索一棵树，程序进入循环，每次循环都访问根节点的每一个子节点，然后将子节点视为根节点进行深度优先搜索。当循环结束也就是每一个子节点都被DFS了一遍，那么整棵树就被DFS了。  
DFS作为一种搜索算法（把所有可能解穷举成图、树并搜索符合要求的路径），不仅能解决本身就是图论的问题，还可以解决那些可以化成图论做的题。比如
>把正整数n分解为小于等于m个不同的正整数，如6=1+2+3，且排在后面的数必须大于等于前面的数，输出所有方案。

首先将将这个问题分为若干层。设方案为将n分为k个整数的和，那么在该方案中，$n=\Sigma_{i=1}^{k}a_i$。程序将在每一层决定$a_i$的值。为了这方案中$a_i$的值，需要三个状态量：  
1. 后面所有正整数的和 $n-\Sigma_{j=1}^{i}a_j$
2. 前一个值$a_i$ 
3. 确保只输出m个正整数的i

以上那个问题暂时放置，进程大概已经是50%

---

第二个问题是luogu P1030，这个问题的思路叙述如下  
* dfs(): 在后序排列中找到根节点并输出，然后在中序排列中dfs(中序左子树，后序左子树)，然后dfs(中序右子树，后序右子树)。

这个dfs()的功能可以理解为“求先序排列”。因为最开始是dfs(中序，后序)，可以理解为根据题目给出的中序和后序排列求出先序排列。而dfs(中序左子树，后序左子树)就是对左子树进行先序排列，符合先序排列的逻辑顺序。  
对于根节点的左子树，程序也是从其左子树进行搜索，体现的就是深度优先搜索dfs  
