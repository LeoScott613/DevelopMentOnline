# 二叉树
*定义不记录*  
## 二叉树物理结构
```c
struct Node {
    int data,
    struct Node *left;
    struct Node *right;
};
```
每一个Node类型的变量的data成员代表二叉树的节点数据，所以不一定是int，可以是其他类型的数据。left成员指向左子树的地址，right成员指向右子树的地址。  
## 遍历
有三种遍历二叉树的方法，分别是先序遍历，中序遍历，后序遍历。  
<del>
**先序遍历：**程序最开始访问根节点，然后访问左子树，再访问右子树。需要注意的是，“访问左子树”指的是遍历完所有左子树的节点。那么根节点的左子树是如何访问的？也是先访问其左子树，再访问其右子树。当左子树是没有的，或者已经结束访问了，那么就访问右子树。  
**中序遍历：**仿照先序遍历，顺序变成这样——先把根节点左子树访问了，再访问根节点，再访问右子树。*为什么先访问左子树被称为中序？猜想可能是因为在人们心中，根节点作为父母节点，在最先，左子树作为大哥，在中间，右子树在最后。。。*  
**后序遍历：**访问顺序：右子树左子树根节点
</del> 

**其实，先后中的意思是根节点在先中后的意思，至于左右，都是左比右先访问**  

## 实际应用的情况
在实际使用二叉树的时候，不一定要去构建二叉树的物理空间。在整数分解这个例子中（*虽然使用的不是二叉树*），程序进入一个循环之后就按照树的结构进行DFS而无需真正构建一棵树。也就是说，这种数据结构在实际使用中，有时候只是给程序的运行提供一个逻辑顺序，也能发挥它的作用。  
总之，实际用于解决问题的时候是不一定需要真正构建一棵树的物理空间的。  